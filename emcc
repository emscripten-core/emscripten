#!/usr/bin/env python2
# -*- Mode: python -*-

'''
emcc - compiler helper script
=============================

emcc is a drop-in replacement for a compiler like gcc or clang.

Tell your build system to use this instead of the compiler, and similarly
use emar, emranlib etc. instead of the same command without 'em'.

Example uses:

 * For configure, instead of ./configure, cmake, etc., run emconfigure.py
   with that command as an argument, for example

    emconfigure.py ./configure [options]

   emconfigure.py is a tiny script that just sets some environment vars
   as a convenience. The command just shown is equivalent to

    EMMAKEN_JUST_CONFIGURE=1 RANLIB=PATH/emranlib AR=PATH/emar CXX=PATH/em++ CC=PATH/emcc ./configure [options]

   where PATH is the path to this file.

   EMMAKEN_JUST_CONFIGURE tells emcc that it is being run in ./configure,
   so it should relay everything to gcc/g++. You should not define that when
   running make, of course.

After setting that up, run your build system normally.

Note the appearance of em++ instead of emcc
for the C++ compiler. This is needed for cases where we get
a C++ file with a C extension, in which case CMake can be told
to run g++ on it despite the .c extension, see

  https://github.com/kripken/emscripten/issues/6

(If a similar situation occurs with ./configure, you can do the same there too.)

emcc can be influenced by a few environment variables:

  EMMAKEN_NO_SDK - Will tell emcc *not* to use the emscripten headers. Instead
                   your system headers will be used.

  EMMAKEN_COMPILER - The compiler to be used, if you don't want the default clang.
'''

import os, sys, shutil, tempfile, subprocess, shlex, time, re, logging
from subprocess import PIPE
from tools import shared, jsrun, system_libs
from tools.shared import Compression, execute, suffix, unsuffixed, unsuffixed_basename, WINDOWS
from tools.response_file import read_response_file

# endings = dot + a suffix, safe to test by  filename.endswith(endings)
C_ENDINGS = ('.c', '.C')
CXX_ENDINGS = ('.cpp', '.cxx', '.cc', '.CPP', '.CXX', '.CC')
OBJC_ENDINGS = ('.m',)
OBJCXX_ENDINGS = ('.mm',)
SOURCE_ENDINGS = C_ENDINGS + CXX_ENDINGS + OBJC_ENDINGS + OBJCXX_ENDINGS
BITCODE_ENDINGS = ('.bc', '.o', '.obj')
DYNAMICLIB_ENDINGS = ('.dylib', '.so', '.dll')
STATICLIB_ENDINGS = ('.a',)
ASSEMBLY_ENDINGS = ('.ll',)
HEADER_ENDINGS = ('.h', '.hxx', '.hpp', '.hh', '.H', '.HXX', '.HPP', '.HH')

LIB_PREFIXES = ('', 'lib')

JS_CONTAINING_SUFFIXES = ('js', 'html')

# Mapping of emcc opt levels to llvm opt levels. We use llvm opt level 3 in emcc opt
# levels 2 and 3 (emcc 3 is unsafe opts, so unsuitable for the only level to get
# llvm opt level 3, and speed-wise emcc level 2 is already the slowest/most optimizing
# level)
LLVM_OPT_LEVEL = {
  0: 0,
  1: 1,
  2: 3,
  3: 3,
}

DEBUG = os.environ.get('EMCC_DEBUG')
if DEBUG == "0":
  DEBUG = None

TEMP_DIR = os.environ.get('EMCC_TEMP_DIR')
LEAVE_INPUTS_RAW = os.environ.get('EMCC_LEAVE_INPUTS_RAW') # Do not compile .ll files into .bc, just compile them with emscripten directly
                                                           # Not recommended, this is mainly for the test runner, or if you have some other
                                                           # specific need.
                                                           # One major limitation with this mode is that libc and libc++ cannot be
                                                           # added in. Also, LLVM optimizations will not be done, nor dead code elimination
AUTODEBUG = os.environ.get('EMCC_AUTODEBUG') # If set to 1, we will run the autodebugger (the automatic debugging tool, see tools/autodebugger).
                                             # Note that this will disable inclusion of libraries. This is useful because including
                                             # dlmalloc makes it hard to compare native and js builds
EMCC_CFLAGS = os.environ.get('EMCC_CFLAGS') # Additional compiler flags that we treat as if they were passed to us on the commandline

logging.debug('invocation: ' + ' '.join(sys.argv) + (' + ' + EMCC_CFLAGS if EMCC_CFLAGS else ''))
if EMCC_CFLAGS: sys.argv.append(EMCC_CFLAGS)

if DEBUG and LEAVE_INPUTS_RAW: logging.warning('leaving inputs raw')

stdout = PIPE if not DEBUG else None # suppress output of child processes
stderr = PIPE if not DEBUG else None # unless we are in DEBUG mode

shared.check_sanity(force=DEBUG)

# Handle some global flags

if len(sys.argv) == 1:
  logging.warning('no input files')
  exit(1)

# read response files very early on
response_file = True
while response_file:
  response_file = None
  for index in range(1, len(sys.argv)):
    if sys.argv[index][0] == '@':
      # found one, loop again next time
      response_file = True
      extra_args = read_response_file(sys.argv[index])
      # slice in extra_args in place of the response file arg
      sys.argv[index:index+1] = extra_args
      break

if len(sys.argv) == 1 or '--help' in sys.argv:
  this = os.path.basename('em++' if os.environ.get('EMMAKEN_CXX') else 'emcc')

  print '''%s [options] file...

Most normal gcc/g++ options will work, for example:
  --help                   Display this information
  --version                Display compiler version information

Options that are modified or new in %s include:

  -O0                      No optimizations (default). This is the recommended
                           setting for starting to port a project, as it
                           includes various assertions.

  -O1                      Simple optimizations, including asm.js, LLVM -O1
                           optimizations, relooping, and no runtime assertions
                           or C++ exception catching (to re-enable
                           C++ exception catching, use
                           -s DISABLE_EXCEPTION_CATCHING=0 ), and enables

                              -s ALIASING_FUNCTION_POINTERS=1

                           This is the recommended setting when you want a
                           reasonably optimized build that is generated as
                           quickly as possible (it builds much faster than -O2).

                           (Note: for details on the affects of different
                           opt levels, see apply_opt_level() in
                           tools/shared.py and also src/settings.js.)

  -O2                      As -O1, plus various js-level optimizations and
                           LLVM -O3 optimizations. This is the recommended
                           setting for a release build: slower compilation
                           time in return for the smallest and fastest
                           output.

  -Os                      Like -O2 with extra optimizations for size.

  -Oz                      Like -Os but reduces code size further.

  -O3                      Like -O2 plus additional JS optimizations that can
                           take a significant amount of compilation time and/or
                           are relatively new. Note that differs from -O2 only
                           during the bitcode to JS (final link + JS generation)
                           stage, as it is JS-specific, so you can run -Os
                           on your source files for example, and -O3 during
                           JS generation if you want.

                           For tips on optimizing your code, see
                           https://github.com/kripken/emscripten/wiki/Optimizing-Code

  -s OPTION=VALUE          JavaScript code generation option passed
                           into the emscripten compiler. For the
                           available options, see src/settings.js
                           Note that for options that are lists, you
                           need quotation marks in most shells, for
                           example

                            -s RUNTIME_LINKED_LIBS="['liblib.so']"

                           or

                            -s "RUNTIME_LINKED_LIBS=['liblib.so']"

                           (without the external "s in either of those,
                           you would get an error)

                           You can also specify a file from which the
                           value would be read, for example,

                            -s DEAD_FUNCTIONS=@/path/to/file

                           The contents of /path/to/file will be read,
                           JSON.parsed and set into DEAD_FUNCTIONS (so
                           the file could contain

                            ["_func1", "func2"]

                           ). Note that the path must be absolute, not
                           relative.

  -g                       Use debug info. When compiling to bitcode,
                           this is the same as in clang and gcc, it
                           adds debug info to the object files. When
                           compiling from source to JS or bitcode to JS,
                           it is equivalent to -g3 (keep code as debuggable
                           as possible, except for discarding LLVM
                           debug info, so no C/C++ line numbers; use
                           -g4 to get line number debugging info in JS).

  -g<level>                When compiling from bitcode to JS, we can
                           keep the code debuggable to different
                           degrees. Each of these levels builds on the
                           previous:

                            -g0  Make no effort to keep code debuggable.
                                 Will discard LLVM debug info. (default
                                 in -O1+)
                            -g1  Preserve (do not minify) whitespace
                            -g2  Preserve function names
                            -g3  Preserve variable names
                            -g4  Preserve LLVM debug info (if -g was
                                 used when compiling the C/C++ sources),
                                 show line number debug comments, and
                                 generate source maps. This is the highest
                                 level of debuggability. Note that this
                                 may make -O1 and above significantly
                                 slower because JS optimization will be
                                 limited to 1 core.  (default in -O0)

  --typed-arrays <mode>    0: No typed arrays
                           1: Parallel typed arrays
                           2: Shared (C-like) typed arrays (default)

  --js-opts                0: Prevent JS optimizer from running
                           1: Use JS optimizer (default)

  --llvm-opts <level>      0: No LLVM optimizations (default in -O0)
                           1: -O1 LLVM optimizations (default in -O1)
                           2: -O2 LLVM optimizations
                           3: -O3 LLVM optimizations (default in -O2+)

                           You can also specify arbitrary LLVM options, e.g.

                             --llvm-opts "['-O3', '-somethingelse']"

  --llvm-lto <level>       0: No LLVM LTO (default)
                           1: LLVM LTO is performed
                           2: We combine all the bitcode and run LLVM opt -O3
                              on that (which optimizes across modules, but is
                              not the same as normal LTO), but do not do normal
                              LTO
                           3: We do both 2 and then 1
                           Note: If LLVM optimizations are not run
                           (see --llvm-opts), setting this has no
                           effect.

                           Note that LLVM LTO is not perfectly stable yet,
                           and can can cause code to behave incorrectly.

  --closure <on>           0: No closure compiler (default in -O2 and below)
                           1: Run closure compiler. This greatly reduces
                           code size and may in some cases increase
                           runtime speed (although the opposite can also
                           occur). Note that it takes time to run, and
                           may require some changes to the code.

                           In asm.js mode, closure will only be used on the
                           'shell' code around the compiled code (the
                           compiled code will be processed by the custom
                           asm.js minifier).

                           Note: If closure compiler hits an out-of-memory,
                           try adjusting JAVA_HEAP_SIZE in the environment
                           (for example, to 4096m for 4GB).

                           Note: Closure is only run if js opts are being
                           done (-O2 or above, or --js-opts 1).

  --pre-js <file>          A file whose contents are added before the
                           generated code. This is done *before*
                           optimization, so it will be minified
                           properly if closure compiler is run.

  --post-js <file>         A file whose contents are added after the
                           generated code This is done *before*
                           optimization, so it will be minified
                           properly if closure compiler is run.

  --embed-file <file>      A file to embed inside the generated
                           JavaScript. The compiled code will be able
                           to access the file in the current directory
                           with the same name as given here. So if
                           you do --embed-file dir/file.dat, then
                           (1) dir/file.dat must exist relative to
                           where you run emcc, and (2) your compiled
                           code will be able to find the file by
                           reading that same path, dir/file.dat.
                           If a directory is passed here, its entire
                           contents will be embedded.

                           Note: Embedding files is much less
                                 efficient than preloading them. You
                                 should only use it for small amounts
                                 of small files. Instead, use
                                 --preload-file which emits efficient
                                 binary data.

  --preload-file <name>    A file to preload before running the
                           compiled code asynchronously. Otherwise
                           similar to --embed-file, except that this
                           option is only relevant when generating
                           HTML (it uses asynchronous binary XHRs),
                           or JS that will be used in a web page.
                           If a directory is passed here, its entire
                           contents will be preloaded.
                           Preloaded files are stored in filename.data,
                           where filename.html is the main file you
                           are compiling to. To run your code, you
                           will need both the .html and the .data.

                           emcc runs tools/file_packager.py to do the
                           actual packaging of embedded and preloaded
                           files. You can run the file packager yourself
                           if you want, see docs inside that file. You
                           should then put the output of the file packager
                           in an emcc --pre-js, so that it executes before
                           your main compiled code (or run it before in
                           some other way).

                           For more docs on the options --preload-file
                           accepts, see  https://github.com/kripken/emscripten/wiki/Filesystem-Guide

  --exclude-file <name>   Files and directories to be excluded from
                           --embed-file and --preload-file
                           wildcard is supported

  --shell-file <path>      The path name to a skeleton HTML file used
                           when generating HTML output. The shell file
                           used needs to have this token inside it:
                           {{{ SCRIPT }}}
                           (see src/shell.html and
                                src/shell_minimal.html for examples)
                           Note that this argument is ignored if a
                           target other than HTML is specified using
                           the -o option.

  --compression <codec>    **THIS OPTION IS DEPRECATED**

                           Compress both the compiled code and embedded/
                           preloaded files. <codec> should be a triple,

                              <native_encoder>,<js_decoder>,<js_name>

                           where native_encoder is a native executable
                           that compresses stdin to stdout (the simplest
                           possible interface), js_decoder is a
                           JavaScript file that implements a decoder,
                           and js_name is the name of the function to
                           call in the decoder file (which should
                           receive an array/typed array and return
                           an array/typed array.
                           Compression only works when generating HTML.
                           When compression is on, all filed specified
                           to be preloaded are compressed in one big
                           archive, which is given the same name as the
                           output HTML but with suffix .data.compress

  --minify 0               Identical to -g1

  --js-transform <cmd>     <cmd> will be called on the generated code
                           before it is optimized. This lets you modify
                           the JavaScript, for example adding some code
                           or removing some code, in a way that those
                           modifications will be optimized together with
                           the generated code properly. <cmd> will be
                           called with the filename of the generated
                           code as a parameter; to modify the code, you
                           can read the original data and then append to
                           it or overwrite it with the modified data.
                           <cmd> is interpreted as a space-separated
                           list of arguments, for example, <cmd> of
                           "python processor.py" will cause a python
                           script to be run.

  --split <size>           Splits the resulting javascript file into pieces
                           to ease debugging. This option only works if
                           Javascript is generated (target -o <name>.js).
                           Files with function declarations must be loaded
                           before main file upon execution.

                           Without "-g" option:
                              Creates files with function declarations up
                              to the given size with the suffix
                              "_functions.partxxx.js" and a main file with
                              the suffix ".js".

                           With "-g" option:
                              Recreates the directory structure of the C
                              source files and stores function declarations
                              in their respective C files with the suffix
                              ".js". If such a file exceeds the given size,
                              files with the suffix ".partxxx.js" are created.
                              The main file resides in the base directory and
                              has the suffix ".js".

                           Note: this option is deprecated (modern JS debuggers
                                 should work ok even on large files)

  --bind                   Compiles the source code using the "embind"
                           bindings approach, which connects C/C++ and JS.

  --ignore-dynamic-linking Normally emcc will treat dynamic linking like
                           static linking, by linking in the code from
                           the dynamic library. This fails if the same
                           dynamic library is linked more than once.
                           With this option, dynamic linking is ignored,
                           which allows the build system to proceed without
                           errors. However, you will need to manually
                           link to the shared libraries later on yourself.

  --js-library <lib>       A JavaScript library to use in addition to
                           those in Emscripten's src/library_*

  -v                       Turns on verbose output. This will pass
                           -v to Clang, and also enable EMCC_DEBUG
                           to details emcc's operations.

                           It will also run emscripten's internal sanity
                           checks, checking that things like the LLVM directory
                           path looks correct, etc. This works with or
                           without other arguments, so it can be useful to run

                              emcc -v

                           if you see odd errors, as it can help diagnose
                           things.

  --clear-cache            Manually clears the cache of compiled
                           emscripten system libraries (libc++,
                           libc++abi, libc). This is normally
                           handled automatically, but if you update
                           llvm in-place (instead of having a different
                           directory for a new version), the caching
                           mechanism can get confused. Clearing the
                           cache can fix weird problems related to
                           cache incompatibilities, like clang failing
                           to link with library files. This also clears
                           other cached data like the jcache and
                           the bootstrapped relooper. After the cache
                           is cleared, this process will exit.

  --save-bc PATH           When compiling to JavaScript or HTML, this
                           option will save a copy of the bitcode to
                           the specified path. The bitcode will include
                           all files being linked, including standard
                           libraries, and after any link-time optimizations
                           (if any).

  --memory-init-file <on>  0: Do not emit a separate memory initialization
                              file, keep the static initialization inside
                              the generated JavaScript as text (default)
                           1: Emit a separate memory initialization file
                              in binary format. This is more efficient than
                              storing it as text inside JavaScript, but does
                              mean you have another file to publish.

  -Wno-warn-absolute-paths If not specified, the compiler will warn about any
                           uses of absolute paths in -I and -L command line
                           directives. Pass this flag on the command line
                           to hide these warnings and acknowledge that the
                           explicit use of absolute paths is intentional.

  --proxy-to-worker        Generates both html and js files. The main
                           program is in js, and the html proxies to/from it.

  --emrun                  Enables the generated output to be aware of the
                           emrun command line tool. This allows stdout, stderr
                           and exit(returncode) capture when running the
                           generated application through emrun.

  --em-config              Specifies the location of the .emscripten configuration
                           file for the current compiler run. If not specified,
                           the environment variable EM_CONFIG is read for this
                           file, and if that is not set, the default location
                           ~/.emscripten is assumed.

  --default-obj-ext .ext   Specifies the file suffix to generate if the location
                           of a directory name is passed to -o directive, e.g.
                             emcc -c a.c -o dir/
                           will by default generate an output name 'dir/a.o',
                           but this cmdline param can be passed to generate a
                           file with a custom suffix 'dir/a.ext'.

The target file, if specified (-o <target>), defines what will
be generated:

  <name>.js                JavaScript
  <name>.html              HTML + side JavaScript file (<name>.js)
                             (JS on the side improves page load time)
  <name>.bc                LLVM bitcode (default)
  <name>.o                 LLVM bitcode (same as .bc)

(Note that if --memory-init-file is used, then in addition to a
.js or .html file that is generated, a .mem file will also appear.)

The -c option (which tells gcc not to run the linker) will
cause LLVM bitcode to be generated, as %s only generates
JavaScript in the final linking stage of building.

The input file(s) can be either source code files that
Clang can handle (C or C++), LLVM bitcode in binary form,
or LLVM assembly files in human-readable form.

emcc is affected by several environment variables. For details, view
the source of emcc (search for 'os.environ').

emcc: supported targets: llvm bitcode, javascript, NOT elf
(autoconf likes to see elf above to enable shared object support)
''' % (this, this, this)
  exit(0)

elif sys.argv[1] == '--version':
  revision = '(unknown revision)'
  here = os.getcwd()
  os.chdir(shared.path_from_root())
  try:
    revision = execute(['git', 'show'], stdout=PIPE, stderr=PIPE)[0].split('\n')[0]
  except:
    pass
  finally:
    os.chdir(here)
  print '''emcc (Emscripten GCC-like replacement) %s (%s)
Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt)
This is free and open source software under the MIT license.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  ''' % (shared.EMSCRIPTEN_VERSION, revision)
  exit(0)

elif len(sys.argv) == 2 and sys.argv[1] == '-v': # -v with no inputs
  print 'emcc (Emscripten GCC-like replacement + linker emulating GNU ld ) %s' % shared.EMSCRIPTEN_VERSION
  code = subprocess.call([shared.CLANG, '-v'])
  shared.check_sanity(force=True)
  exit(code)

def is_minus_s_for_emcc(newargs, i):
  assert newargs[i] == '-s'
  if i+1 < len(newargs) and '=' in newargs[i+1]: # -s OPT=VALUE is for us, -s by itself is a linker option
    return True
  else:
    logging.warning('treating -s as linker option and not as -s OPT=VALUE for js compilation')
    return False

# If this is a configure-type thing, do not compile to JavaScript, instead use clang
# to compile to a native binary (using our headers, so things make sense later)
CONFIGURE_CONFIG = (os.environ.get('EMMAKEN_JUST_CONFIGURE') or 'conftest.c' in sys.argv) and not os.environ.get('EMMAKEN_JUST_CONFIGURE_RECURSE')
CMAKE_CONFIG = 'CMakeFiles/cmTryCompileExec.dir' in ' '.join(sys.argv)# or 'CMakeCCompilerId' in ' '.join(sys.argv)
if CONFIGURE_CONFIG or CMAKE_CONFIG:
  debug_configure = 0 # XXX use this to debug configure stuff. ./configure's generally hide our normal output including stderr so we write to a file
  use_js = os.environ.get('EMCONFIGURE_JS') # whether we fake configure tests using clang - the local, native compiler - or not. if not we generate JS and use node with a shebang
                   # neither approach is perfect, you can try both, but may need to edit configure scripts in some cases
                   # XXX False is not fully tested yet

  if debug_configure:
    tempout = '/tmp/emscripten_temp/out'
    if not os.path.exists(tempout):
      open(tempout, 'w').write('//\n')

  src = None
  for arg in sys.argv:
    if arg.endswith('.c'):
      try:
        src = open(arg).read()
        if debug_configure: open(tempout, 'a').write('============= ' + arg + '\n' + src + '\n=============\n\n')
      except:
        pass
    elif arg.endswith('.s'):
      if debug_configure: open(tempout, 'a').write('(compiling .s assembly, must use clang\n')
      use_js = 0
    elif arg == '-E':
      use_js = 0

  if src:
    if 'fopen' in src and '"w"' in src:
      use_js = 0 # we cannot write to files from js!
      if debug_configure: open(tempout, 'a').write('Forcing clang since uses fopen to write\n')

  compiler = os.environ.get('CONFIGURE_CC') or (shared.CLANG if not use_js else shared.EMCC) # if CONFIGURE_CC is defined, use that. let's you use local gcc etc. if you need that
  if not ('CXXCompiler' in ' '.join(sys.argv) or os.environ.get('EMMAKEN_CXX')):
    compiler = shared.to_cc(compiler)

  def filter_emscripten_options(argv):
    idx = 0
    skip_next = False
    for el in argv:
      if skip_next:
        skip_next = False
        idx += 1
        continue
      if not use_js and el == '-s' and is_minus_s_for_emcc(argv, idx): # skip -s X=Y if not using js for configure
        skip_next = True
      else:
        yield el
      idx += 1

  cmd = [compiler] + list(filter_emscripten_options(sys.argv[1:]))
  if not use_js: cmd += shared.EMSDK_OPTS + ['-D__EMSCRIPTEN__', '-DEMSCRIPTEN']
  if use_js: cmd += ['-s', 'ERROR_ON_UNDEFINED_SYMBOLS=1'] # configure tests should fail when an undefined symbol exists

  logging.debug('just configuring: ' + ' '.join(cmd))
  if debug_configure: open(tempout, 'a').write('emcc, just configuring: ' + ' '.join(cmd) + '\n\n')

  if not use_js:
    exit(subprocess.call(cmd))
  else:
    only_object = '-c' in cmd
    target = None
    for i in range(len(cmd)-1):
      if cmd[i] == '-o':
        if not only_object:
          cmd[i+1] += '.js'
        target = cmd[i+1]
        break
    print 't1', target
    if not target:
      target = 'a.out.js'
    print 't2', target, only_object
    os.environ['EMMAKEN_JUST_CONFIGURE_RECURSE'] = '1'
    ret = subprocess.call(cmd)
    os.environ['EMMAKEN_JUST_CONFIGURE_RECURSE'] = ''
    if not os.path.exists(target): exit(1)
    if target.endswith('.js'):
      shutil.copyfile(target, target[:-3])
      target = target[:-3]
    src = open(target).read()
    full_node = ' '.join(shared.listify(shared.NODE_JS))
    if os.path.sep not in full_node:
      full_node = '/usr/bin/' + full_node # TODO: use whereis etc. And how about non-*NIX?
    open(target, 'w').write('#!' + full_node + '\n' + src) # add shebang
    import stat
    os.chmod(target, stat.S_IMODE(os.stat(target).st_mode) | stat.S_IXUSR) # make executable
    exit(ret)

if os.environ.get('EMMAKEN_COMPILER'):
  CXX = os.environ['EMMAKEN_COMPILER']
else:
  CXX = shared.CLANG

CC = shared.to_cc(CXX)

# If we got here from a redirection through emmakenxx.py, then force a C++ compiler here
if os.environ.get('EMMAKEN_CXX'):
  CC = CXX

CC_ADDITIONAL_ARGS = shared.COMPILER_OPTS

EMMAKEN_CFLAGS = os.environ.get('EMMAKEN_CFLAGS')
if EMMAKEN_CFLAGS: sys.argv += shlex.split(EMMAKEN_CFLAGS)

# ---------------- Utilities ---------------

seen_names = {}
def uniquename(name):
  if name not in seen_names:
    seen_names[name] = str(len(seen_names))
  return unsuffixed(name) + '_' + seen_names[name] + (('.' + suffix(name)) if suffix(name) else '')

# ---------------- End configs -------------

if len(sys.argv) == 1 or sys.argv[1] in ['x', 't']:
  # noop ar
  logging.debug('just ar')
  sys.exit(0)

use_cxx = True

for i in range(1, len(sys.argv)):
  arg = sys.argv[i]
  if not arg.startswith('-'):
    if arg.endswith(C_ENDINGS + OBJC_ENDINGS):
      use_cxx = False

if '-M' in sys.argv or '-MM' in sys.argv:
  # Just output dependencies, do not compile. Warning: clang and gcc behave differently with -MF! (clang seems to not recognize it)
  cmd = [CC] + shared.COMPILER_OPTS + sys.argv[1:]
  logging.debug('just dependencies: ' + ' '.join(cmd))
  exit(subprocess.call(cmd))

if '-E' in sys.argv:
  # Just run the preprocessor
  cmd = [CC] + sys.argv[1:]
  logging.debug('just preprocessor ' + ' '.join(cmd))
  exit(subprocess.call(cmd))

# Check if a target is specified
target = None
for i in range(len(sys.argv)-1):
  if sys.argv[i].startswith('-o='):
    raise Exception('Invalid syntax: do not use -o=X, use -o X')

  if sys.argv[i] == '-o':
    target = sys.argv[i+1]
    sys.argv = sys.argv[:i] + sys.argv[i+2:]
    break

specified_target = target
target = specified_target if specified_target is not None else 'a.out.js' # specified_target is the user-specified one, target is what we will generate
target_basename = unsuffixed_basename(target)

if '.' in target:
  final_suffix = target.split('.')[-1]
else:
  final_suffix = ''

if TEMP_DIR:
  temp_dir = TEMP_DIR
  if os.path.exists(temp_dir):
    shutil.rmtree(temp_dir) # clear it
  os.makedirs(temp_dir)
else:
  temp_root = shared.TEMP_DIR
  if not os.path.exists(temp_root):
    os.makedirs(temp_root)
  temp_dir = tempfile.mkdtemp(dir=temp_root)

def in_temp(name):
  return os.path.join(temp_dir, os.path.basename(name))

# Parses the essential suffix of a filename, discarding Unix-style version numbers in the name. For example for 'libz.so.1.2.8' returns '.so'
def filename_type_suffix(filename):
  for i in reversed(filename.split('.')[1:]):
    if not i.isdigit():
      return i
  return ''

def filename_type_ending(filename):
  suffix = filename_type_suffix(filename)
  return '' if not suffix else ('.' + suffix)

# Log out times for emcc stages
log_time_last = time.time()
def log_time(name):
  global log_time_last
  now = time.time()
  logging.debug('emcc step "%s" took %.2f seconds', name, now - log_time_last)
  log_time_last = now

try:
  call = CXX if use_cxx else CC

  ## Parse args

  newargs = sys.argv[1:]

  opt_level = 0
  debug_level = 0
  js_opts = None
  llvm_opts = None
  llvm_lto = None
  closure = None
  js_transform = None
  pre_js = ''
  post_js = ''
  split_js_file = None
  preload_files = []
  embed_files = []
  exclude_files = []
  compression = None
  ignore_dynamic_linking = False
  shell_path = shared.path_from_root('src', 'shell.html')
  js_libraries = []
  bind = False
  emrun = False
  jcache = False
  save_bc = False
  memory_init_file = False
  use_preload_cache = False
  no_heap_copy = False
  proxy_to_worker = False
  default_object_extension = '.o'

  if use_cxx:
    default_cxx_std = '-std=c++03' # Enforce a consistent C++ standard when compiling .cpp files, if user does not specify one on the cmdline.
  else:
    default_cxx_std = '' # Compiling C code with .c files, don't enforce a default C++ std.

  def check_bad_eq(arg):
    assert '=' not in arg, 'Invalid parameter (do not use "=" with "--" options)'

  absolute_warning_shown = False

  # Scan for warning suppression message in advance from other cmdline flags, so that it works even if -I or -L directives are present before this.
  for i in range(len(newargs)):
    if newargs[i] == '-Wno-warn-absolute-paths':
      newargs[i] = ''
      absolute_warning_shown = True

  settings_changes = []

  def validate_arg_level(level_string, max_level, err_msg):
    try:
      level = int(level_string)
      assert 0 <= level <= max_level
    except:
      raise Exception(err_msg)
    return level

  for i in range(len(newargs)):
    newargs[i] = newargs[i].strip() # On Windows Vista (and possibly others), excessive spaces in the command line leak into the items in this array, so trim e.g. 'foo.cpp ' -> 'foo.cpp'
    if newargs[i].startswith('-O'):
      # Let -O default to -O2, which is what gcc does.
      requested_level = newargs[i][2:] or '2'
      if requested_level == 's':
        llvm_opts = ['-Os']
        requested_level = 2
        settings_changes.append('INLINING_LIMIT=50')
      elif requested_level == 'z':
        llvm_opts = ['-Oz']
        requested_level = 2
        settings_changes.append('INLINING_LIMIT=25')
      opt_level = validate_arg_level(requested_level, 3, 'Invalid optimization level: ' + newargs[i])
      # We leave the -O option in place so that the clang front-end runs in that
      # optimization mode, but we disable the actual optimization passes, as we'll
      # run them seperately.
      newargs.append('-mllvm')
      newargs.append('-disable-llvm-optzns')
    elif newargs[i].startswith('--js-opts'):
      check_bad_eq(newargs[i])
      js_opts = eval(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--llvm-opts'):
      check_bad_eq(newargs[i])
      llvm_opts = eval(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--llvm-lto'):
      check_bad_eq(newargs[i])
      llvm_lto = eval(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--closure'):
      check_bad_eq(newargs[i])
      closure = int(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--js-transform'):
      check_bad_eq(newargs[i])
      js_transform = newargs[i+1]
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--pre-js'):
      check_bad_eq(newargs[i])
      pre_js += open(newargs[i+1]).read() + '\n'
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--post-js'):
      check_bad_eq(newargs[i])
      post_js += open(newargs[i+1]).read() + '\n'
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--minify'):
      check_bad_eq(newargs[i])
      assert newargs[i+1] == '0', '0 is the only supported option for --minify; 1 has been deprecated'
      debug_level = max(1, debug_level)
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--split'):
      check_bad_eq(newargs[i])
      split_js_file = int(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('-g'):
      requested_level = newargs[i][2:] or '3'
      debug_level = validate_arg_level(requested_level, 4, 'Invalid debug level: ' + newargs[i])
      newargs[i] = '-g' # we'll need this to get LLVM debug info
    elif newargs[i] == '--bind':
      bind = True
      newargs[i] = ''
      if default_cxx_std:
        default_cxx_std = '-std=c++11' # Force C++11 for embind code, but only if user has not explicitly overridden a standard.
    elif newargs[i].startswith('-std='):
      default_cxx_std = '' # User specified a standard to use, clear Emscripten from specifying it.
    elif newargs[i].startswith('--embed-file'):
      check_bad_eq(newargs[i])
      embed_files.append(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--preload-file'):
      check_bad_eq(newargs[i])
      preload_files.append(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--exclude-file'):
      check_bad_eq(newargs[i])
      exclude_files.append(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--compression'):
      logging.warning('--compression is deprecated. Instead, it is recommended you use native gzip compression in your webserver')
      check_bad_eq(newargs[i])
      parts = newargs[i+1].split(',')
      assert len(parts) == 3, '--compression requires specifying    native_encoder,js_decoder,js_name  - see emcc --help. got: %s' % newargs[i+1]
      def locate(tool):
        if WINDOWS:
          if os.path.exists(tool+'.exe'):
            return tool+'.exe'
          if os.path.exists(tool+'.bat'):
            return tool+'.bat'
          if os.path.exists(tool+'.cmd'):
            return tool+'.cmd'
        return tool
      Compression.encoder = locate(parts[0])
      Compression.decoder = locate(parts[1])
      Compression.js_name = parts[2]
      assert os.path.exists(Compression.encoder), 'native encoder %s does not exist' % Compression.encoder
      assert os.path.exists(Compression.decoder), 'js decoder %s does not exist' % Compression.decoder
      Compression.on = True
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--use-preload-cache'):
      use_preload_cache = True
      newargs[i] = ''
    elif newargs[i].startswith('--no-heap-copy'):
      no_heap_copy = True
      newargs[i] = ''
    elif newargs[i] == '--ignore-dynamic-linking':
      ignore_dynamic_linking = True
      newargs[i] = ''
    elif newargs[i] == '-v':
      shared.COMPILER_OPTS += ['-v']
      os.environ['EMCC_DEBUG'] = '1' # send to child processes too
      if DEBUG != 1:
        # swap in debug logging
        DEBUG = 1
        shared.set_logging()
        logging.debug('invocation: ' + ' '.join(sys.argv))
        shared.apply_configuration() # reset config to pick up change
        shared.check_sanity(force=True)
      newargs[i] = ''
    elif newargs[i].startswith('--shell-file'):
      check_bad_eq(newargs[i])
      shell_path = newargs[i+1]
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i].startswith('--js-library'):
      check_bad_eq(newargs[i])
      js_libraries.append(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i] == '--remove-duplicates':
      logging.warning('--remove-duplicates is deprecated as it is no longer needed. If you cannot link without it, file a bug with a testcase')
      newargs[i] = ''
    elif newargs[i] == '--jcache':
      logging.warning('jcache is deprecated')
      jcache = True
      newargs[i] = ''
    elif newargs[i] == '--clear-cache':
      newargs[i] = ''
      logging.warning('clearing cache')
      shared.Cache.erase()
      shared.check_sanity(force=True) # this is a good time for a sanity check
      sys.exit(0)
    elif newargs[i] == '--save-bc':
      check_bad_eq(newargs[i])
      save_bc = newargs[i+1]
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i] == '--memory-init-file':
      check_bad_eq(newargs[i])
      memory_init_file = int(newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i] == '--proxy-to-worker':
      proxy_to_worker = True
      newargs[i] = ''
    elif newargs[i].startswith(('-I', '-L')):
      path_name = newargs[i][2:]
      if not absolute_warning_shown and os.path.isabs(path_name):
        logging.warning('-I or -L of an absolute path "' + newargs[i] + '" encountered. If this is to a local system header/library, it may cause problems (local system files make sense for compiling natively on your system, but not necessarily to JavaScript). Pass \'-Wno-warn-absolute-paths\' to emcc to hide this warning.') # Of course an absolute path to a non-system-specific library or header is fine, and you can ignore this warning. The danger are system headers that are e.g. x86 specific and nonportable. The emscripten bundled headers are modified to be portable, local system ones are generally not
        absolute_warning_shown = True
    elif newargs[i] == '--emrun':
      emrun = True
      newargs[i] = ''
    elif newargs[i] == '--em-config':
      # This option is parsed in tools/shared.py, here only clean it up from being passed to clang.
      newargs[i] = ''
      newargs[i+1] = ''
    elif newargs[i] == '--default-obj-ext':
      newargs[i] = ''
      default_object_extension = newargs[i+1]
      if not default_object_extension.startswith('.'):
        default_object_extension = '.' + default_object_extension
      newargs[i+1] = ''

  newargs = [arg for arg in newargs if arg is not '']

  # If user did not specify a default -std for C++ code, specify the emscripten default.
  if default_cxx_std:
    newargs = newargs + [default_cxx_std]

  if emrun:
    pre_js += open(shared.path_from_root('src', 'emrun_prejs.js')).read() + '\n'
    post_js += open(shared.path_from_root('src', 'emrun_postjs.js')).read() + '\n'

  if js_opts is None: js_opts = opt_level >= 2
  if llvm_opts is None: llvm_opts = LLVM_OPT_LEVEL[opt_level]
  if opt_level == 0: debug_level = 4

  if llvm_lto is None and bind:
    logging.debug('running lto for embind') # XXX this is a workaround for a pointer issue
    llvm_lto = 1

  # TODO: support source maps with js_transform
  if js_transform and debug_level >= 4:
    logging.warning('disabling source maps because a js transform is being done')
    debug_level = 3

  if DEBUG: start_time = time.time() # done after parsing arguments, which might affect debug state

  if closure:
    assert os.path.exists(shared.CLOSURE_COMPILER), logging.error('fatal: Closure compiler (%s) does not exist', shared.CLOSURE_COMPILER)

  for i in range(len(newargs)):
    if newargs[i] == '-s':
      if is_minus_s_for_emcc(newargs, i):
        settings_changes.append(newargs[i+1])
        newargs[i] = newargs[i+1] = ''
    elif newargs[i].startswith('--typed-arrays'):
      assert '=' not in newargs[i], 'Invalid typed arrays parameter (do not use "=")'
      settings_changes.append('USE_TYPED_ARRAYS=' + newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
  newargs = [arg for arg in newargs if arg is not '']

  if split_js_file:
    settings_changes.append("PRINT_SPLIT_FILE_MARKER=1")

  # Find input files

  input_files = []
  has_source_inputs = False
  has_header_inputs = False
  lib_dirs = [shared.path_from_root('system', 'local', 'lib'),
              shared.path_from_root('system', 'lib')]
  libs = []
  for i in range(len(newargs)): # find input files XXX this a simple heuristic. we should really analyze based on a full understanding of gcc params,
                                # right now we just assume that what is left contains no more |-x OPT| things
    arg = newargs[i]

    if i > 0:
      prev = newargs[i-1]
      if prev in ['-MT', '-MF', '-MQ', '-D', '-U', '-o', '-x', '-Xpreprocessor', '-include', '-imacros', '-idirafter', '-iprefix', '-iwithprefix', '-iwithprefixbefore', '-isysroot', '-imultilib', '-A', '-isystem', '-iquote', '-install_name', '-compatibility_version', '-current_version', '-I', '-L']: continue # ignore this gcc-style argument

    if os.path.islink(arg) and os.path.realpath(arg).endswith(SOURCE_ENDINGS + BITCODE_ENDINGS + DYNAMICLIB_ENDINGS + ASSEMBLY_ENDINGS + HEADER_ENDINGS):
      arg = os.path.realpath(arg)

    if not arg.startswith('-'):
      if not os.path.exists(arg):
        logging.error('%s: No such file or directory ("%s" was expected to be an input file, based on the commandline arguments provided)', arg, arg)
        exit(1)

      arg_ending = filename_type_ending(arg)
      if arg_ending.endswith(SOURCE_ENDINGS + BITCODE_ENDINGS + DYNAMICLIB_ENDINGS + ASSEMBLY_ENDINGS + HEADER_ENDINGS) or shared.Building.is_ar(arg): # we already removed -o <target>, so all these should be inputs
        newargs[i] = ''
        if arg_ending.endswith(SOURCE_ENDINGS):
          input_files.append(arg)
          has_source_inputs = True
        elif arg_ending.endswith(HEADER_ENDINGS):
          input_files.append(arg)
          has_header_inputs = True
        elif arg_ending.endswith(ASSEMBLY_ENDINGS) or shared.Building.is_bitcode(arg): # this should be bitcode, make sure it is valid
          input_files.append(arg)
        elif arg_ending.endswith(STATICLIB_ENDINGS + DYNAMICLIB_ENDINGS):
          # if it's not, and it's a library, just add it to libs to find later
          l = unsuffixed_basename(arg)
          for prefix in LIB_PREFIXES:
            if not prefix: continue
            if l.startswith(prefix):
              l = l[len(prefix):]
              break
          libs.append(l)
          newargs[i] = ''
        else:
          logging.warning(arg + ' is not valid LLVM bitcode')
      elif arg_ending.endswith(STATICLIB_ENDINGS):
        if not shared.Building.is_ar(arg):
          if shared.Building.is_bitcode(arg):
            logging.error(arg + ': File has a suffix of a static library ' + str(STATICLIB_ENDINGS) + ', but instead is an LLVM bitcode file! When linking LLVM bitcode files, use one of the suffixes ' + str(BITCODE_ENDINGS))
          else:
            logging.error(arg + ': Unknown format, not a static library!')
          exit(1)
      else:
        logging.error(arg + ": Input file has an unknown suffix, don't know what to do with it!")
        exit(1)
    elif arg.startswith('-L'):
      lib_dirs.append(arg[2:])
      newargs[i] = ''
    elif arg.startswith('-l'):
      libs.append(arg[2:])
      newargs[i] = ''

  original_input_files = input_files[:]

  newargs = [arg for arg in newargs if arg is not '']

  # -c means do not link in gcc, and for us, the parallel is to not go all the way to JS, but stop at bitcode
  has_dash_c = '-c' in newargs
  if has_dash_c:
    assert has_source_inputs or has_header_inputs, 'Must have source code or header inputs to use -c'
    target = target_basename + '.o'
    final_suffix = 'o'

  # Find library files
  for lib in libs:
    logging.debug('looking for library "%s"', lib)
    found = False
    for prefix in LIB_PREFIXES:
      for suff in STATICLIB_ENDINGS + DYNAMICLIB_ENDINGS:
        name = prefix + lib + suff
        for lib_dir in lib_dirs:
          path = os.path.join(lib_dir, name)
          if os.path.exists(path):
            logging.debug('found library "%s" at %s', lib, path)
            input_files.append(path)
            found = True
            break
        if found: break
      if found: break
    if not found: logging.warning('emcc: cannot find library "%s"', lib)

  # If not compiling to JS, then we are compiling to an intermediate bitcode objects or library, so
  # ignore dynamic linking, since multiple dynamic linkings can interfere with each other
  if not filename_type_suffix(target) in JS_CONTAINING_SUFFIXES or ignore_dynamic_linking:
    def check(input_file):
      if filename_type_ending(input_file) in DYNAMICLIB_ENDINGS:
        if not ignore_dynamic_linking: logging.warning('ignoring dynamic library %s because not compiling to JS or HTML, remember to link it when compiling to JS or HTML at the end', os.path.basename(input_file))
        return False
      else:
        return True
    input_files = [input_file for input_file in input_files if check(input_file)]

  if len(input_files) == 0:
    logging.error('no input files\nnote that input files without a known suffix are ignored, make sure your input files end with one of: ' + str(SOURCE_ENDINGS + BITCODE_ENDINGS + DYNAMICLIB_ENDINGS + STATICLIB_ENDINGS + ASSEMBLY_ENDINGS + HEADER_ENDINGS))
    exit(0)

  newargs = CC_ADDITIONAL_ARGS + newargs

  assert not (Compression.on and final_suffix != 'html'), 'Compression only works when generating HTML'

  # If we are using embind and generating JS, now is the time to link in bind.cpp
  if bind and final_suffix in JS_CONTAINING_SUFFIXES:
    input_files.append(shared.path_from_root('system', 'lib', 'embind', 'bind.cpp'))

  # Apply optimization level settings
  shared.Settings.apply_opt_level(opt_level, noisy=True)

  # Apply -s settings in newargs here (after optimization levels, so they can override them)
  for change in settings_changes:
    key, value = change.split('=')
    if value[0] == '@':
      value = '"@' + os.path.abspath(value[1:]) + '"'
      value = value.replace('\\\\', '/').replace('\\', '/') # Convert backslash paths to forward slashes on Windows as well, since the JS compiler otherwise needs the backslashes escaped (alternative is to escape all input paths passing to JS, which feels clumsier to read)
    exec('shared.Settings.' + key + ' = ' + value)

  # Apply effects from settings
  if bind and shared.Settings.ASM_JS:
    logging.warning('disabling asm.js since embind is not ready for it yet')
    shared.Settings.ASM_JS = 0

  fastcomp = os.environ.get('EMCC_FAST_COMPILER') != '0'

  if fastcomp:
    shared.Settings.ASM_JS = 1 if opt_level > 0 else 2
    try:
      assert shared.Settings.UNALIGNED_MEMORY == 0, 'forced unaligned memory not supported in fastcomp'
      assert shared.Settings.CHECK_HEAP_ALIGN == 0, 'check heap align not supported in fastcomp yet'
      assert shared.Settings.SAFE_DYNCALLS == 0, 'safe dyncalls not supported in fastcomp'
      assert shared.Settings.ASM_HEAP_LOG == 0, 'asm heap log not supported in fastcomp'
      assert shared.Settings.LABEL_DEBUG == 0, 'label debug not supported in fastcomp'
      assert shared.Settings.EXECUTION_TIMEOUT == -1, 'execution timeout not supported in fastcomp'
      assert shared.Settings.NAMED_GLOBALS == 0, 'named globals not supported in fastcomp'
      assert shared.Settings.PGO == 0, 'pgo not supported in fastcomp'
      assert shared.Settings.TARGET_ASMJS_UNKNOWN_EMSCRIPTEN == 1, 'fastcomp requires asmjs-unknown-emscripten'
      assert shared.Settings.USE_TYPED_ARRAYS == 2, 'fastcomp assumes ta2'
      assert not split_js_file, '--split-js is deprecated and not supported in fastcomp'
      assert not bind, 'embind not supported in fastcomp yet'
      assert shared.Settings.MAX_SETJMPS == 20, 'changing MAX_SETJMPS is not supported in fastcomp yet'
      assert shared.Settings.INIT_HEAP == 0, 'HEAP_INIT is not supported in fastcomp (and should never be needed except for debugging)'
      assert not shared.Settings.RUNTIME_TYPE_INFO, 'RUNTIME_TYPE_INFO is not supported in fastcomp'
      assert not shared.Settings.CORRUPTION_CHECK, 'CORRUPTION_CHECK is not supported in asm.js mode, which is what fastcomp can emit (you can use non-asm.js mode in non-fastcomp)'
    except Exception, e:
      logging.error('Compiler settings are incompatible with fastcomp. You can fall back to the older compiler core, although that is not recommended, see https://github.com/kripken/emscripten/wiki/LLVM-Backend')
      raise e

    if jcache:
      logging.warning('jcache is deprecated and not supported in fastcomp (you should not need it anyhow), disabling')
      jcache = False

    pre_fastcomp_opts = []
    fastcomp_opts = []
    if shared.Settings.NO_EXIT_RUNTIME:
      pre_fastcomp_opts += ['-emscripten-no-exit-runtime']
      if not llvm_lto: fastcomp_opts += ['-globalopt', '-globaldce']
    fastcomp_opts += ['-pnacl-abi-simplify-preopt', '-pnacl-abi-simplify-postopt']
    if shared.Settings.DISABLE_EXCEPTION_CATCHING != 1:
      fastcomp_opts += ['-enable-emscripten-cxx-exceptions']
      if len(shared.Settings.EXCEPTION_CATCHING_WHITELIST) > 0:
        fastcomp_opts += ['-emscripten-cxx-exceptions-whitelist=' + ','.join(shared.Settings.EXCEPTION_CATCHING_WHITELIST)]

  if shared.Settings.ASM_JS:
    assert opt_level >= 1 or fastcomp, 'asm.js requires -O1 or above'

    if bind:
      shared.Settings.RESERVED_FUNCTION_POINTERS = max(shared.Settings.RESERVED_FUNCTION_POINTERS, 10)
    if shared.Settings.CORRECT_SIGNS != 1:
      logging.warning('setting CORRECT_SIGNS to 1 for asm.js code generation')
      shared.Settings.CORRECT_SIGNS = 1
    if shared.Settings.CORRECT_OVERFLOWS != 1:
      logging.warning('setting CORRECT_OVERFLOWS to 1 for asm.js code generation')
      shared.Settings.CORRECT_OVERFLOWS = 1
    assert not shared.Settings.PGO, 'cannot run PGO in ASM_JS mode'

    if shared.Settings.SAFE_HEAP and not js_opts:
      js_opts = True
      logging.warning('enabling js opts to allow SAFE_HEAP to work properly')

    if shared.Settings.ALLOW_MEMORY_GROWTH:
      logging.warning('Disabling asm.js validation for memory growth (memory can grow, but you lose some amount of speed)');
      shared.Settings.ASM_JS = 2

  if shared.Settings.CORRECT_SIGNS >= 2 or shared.Settings.CORRECT_OVERFLOWS >= 2 or shared.Settings.CORRECT_ROUNDINGS >= 2:
    debug_level = 4 # must keep debug info to do line-by-line operations

  if debug_level > 1 and closure:
    logging.warning('disabling closure because debug info was requested')
    closure = False

  assert shared.LLVM_TARGET in shared.COMPILER_OPTS
  if shared.LLVM_TARGET == 'i386-pc-linux-gnu':
    shared.Settings.TARGET_X86 = 1
    shared.Settings.TARGET_ASMJS_UNKNOWN_EMSCRIPTEN = 0
    assert 'asmjs-unknown-emscripten' not in shared.COMPILER_OPTS
  elif shared.LLVM_TARGET == 'asmjs-unknown-emscripten' or \
       shared.LLVM_TARGET == 'le32-unknown-nacl':
    # For temporary compatibility, treat 'le32-unknown-nacl' as 'asmjs-unknown-emscripten'.
    shared.Settings.TARGET_ASMJS_UNKNOWN_EMSCRIPTEN = 1
    shared.Settings.TARGET_X86 = 0
    assert 'i386-pc-linux-gnu' not in shared.COMPILER_OPTS
  else:
    raise Exception('unknown llvm target: ' + str(shared.LLVM_TARGET))

  if shared.Settings.USE_TYPED_ARRAYS != 2 and llvm_opts > 0:
    logging.warning('disabling LLVM optimizations, need typed arrays mode 2 for them')
    llvm_opts = 0

  if shared.Settings.MAIN_MODULE:
    assert not shared.Settings.SIDE_MODULE
    shared.Settings.INCLUDE_FULL_LIBRARY = 1
  elif shared.Settings.SIDE_MODULE:
    assert not shared.Settings.MAIN_MODULE

  if shared.Settings.MAIN_MODULE or shared.Settings.SIDE_MODULE:
    assert not memory_init_file, 'memory init file is not supported with module linking'
    assert shared.Settings.ASM_JS, 'module linking requires asm.js output (-s ASM_JS=1)'
    shared.Settings.LINKABLE = 1 # TODO: add FORCE_DCE option for the brave people that do want to dce here and in side modules
    debug_level = max(debug_level, 2)

  if not fastcomp and shared.Settings.ASSERTIONS and shared.Settings.ALIASING_FUNCTION_POINTERS:
    logging.warning('ALIASING_FUNCTION_POINTERS is on, function pointer comparisons may be invalid across types')

  if shared.Settings.STB_IMAGE and final_suffix in JS_CONTAINING_SUFFIXES:
    input_files.append(shared.path_from_root('third_party', 'stb_image.c'))
    shared.Settings.EXPORTED_FUNCTIONS += ['_stbi_load', '_stbi_load_from_memory', '_stbi_image_free']

  if type(shared.Settings.EXPORTED_FUNCTIONS) in (list, tuple):
    # always need malloc and free to be kept alive and exported, for internal use and other modules
    for required_export in ['_malloc', '_free']:
      if required_export not in shared.Settings.EXPORTED_FUNCTIONS:
        shared.Settings.EXPORTED_FUNCTIONS.append(required_export)
  else:
    logging.debug('using response file for EXPORTED_FUNCTIONS, make sure it includes _malloc and _free')

  if shared.Settings.ASM_JS and shared.Settings.DLOPEN_SUPPORT:
    assert shared.Settings.DISABLE_EXCEPTION_CATCHING, 'no exceptions support with dlopen in asm yet'

  if proxy_to_worker:
    shared.Settings.PROXY_TO_WORKER = 1

  if js_opts:
    shared.Settings.RUNNING_JS_OPTS = 1

  shared.Settings.EMSCRIPTEN_VERSION = shared.EMSCRIPTEN_VERSION
  shared.Settings.OPT_LEVEL = opt_level
  shared.Settings.DEBUG_LEVEL = debug_level

  ## Compile source code to bitcode

  logging.debug('compiling to bitcode')

  temp_files = []

  log_time('parse arguments and setup')

  # Precompiled headers support
  if has_header_inputs:
    for header in input_files:
      assert header.endswith(HEADER_ENDINGS), 'if you have one header input, we assume you want to precompile headers, and cannot have source files or other inputs as well: ' + str(input_files) + ' : ' + header
    args = newargs + shared.EMSDK_CXX_OPTS + input_files
    logging.debug("running (for precompiled headers: " + call + ' ' + ' '.join(args))
    execute([call] + args) # let compiler frontend print directly, so colors are saved (PIPE kills that)
    sys.exit(1)

  # First, generate LLVM bitcode. For each input file, we get base.o with bitcode
  for input_file in input_files:
    file_ending = filename_type_ending(input_file)
    if file_ending.endswith(SOURCE_ENDINGS):
      logging.debug('compiling source file: ' + input_file)
      input_file = shared.Building.preprocess(input_file, in_temp(uniquename(input_file)))
      output_file = in_temp(unsuffixed(uniquename(input_file)) + '.o')
      temp_files.append(output_file)
      args = newargs + ['-emit-llvm', '-c', input_file, '-o', output_file]
      if file_ending.endswith(CXX_ENDINGS):
        args += shared.EMSDK_CXX_OPTS
      logging.debug("running: " + call + ' ' + ' '.join(args))
      execute([call] + args) # let compiler frontend print directly, so colors are saved (PIPE kills that)
      if not os.path.exists(output_file):
        logging.error('compiler frontend failed to generate LLVM bitcode, halting')
        sys.exit(1)
    else: # bitcode
      if file_ending.endswith(BITCODE_ENDINGS):
        logging.debug('copying bitcode file: ' + input_file)
        temp_file = in_temp(unsuffixed(uniquename(input_file)) + '.o')
        shutil.copyfile(input_file, temp_file)
        temp_files.append(temp_file)
      elif file_ending.endswith(DYNAMICLIB_ENDINGS) or shared.Building.is_ar(input_file):
        logging.debug('copying library file: ' + input_file)
        temp_file = in_temp(uniquename(input_file))
        shutil.copyfile(input_file, temp_file)
        temp_files.append(temp_file)
      elif file_ending.endswith(ASSEMBLY_ENDINGS):
        if not LEAVE_INPUTS_RAW:
          # Note that by assembling the .ll file, then disassembling it later, we will
          # remove annotations which is a good thing for compilation time
          logging.debug('assembling assembly file: ' + input_file)
          temp_file = in_temp(unsuffixed(uniquename(input_file)) + '.o')
          shared.Building.llvm_as(input_file, temp_file)
          temp_files.append(temp_file)
      else:
        logging.error(input_file + ': Unknown file suffix when compiling to LLVM bitcode!')
        sys.exit(1)

  log_time('bitcodeize inputs')

  if not LEAVE_INPUTS_RAW:
    assert len(temp_files) == len(input_files)

    # Optimize source files
    if llvm_opts > 0:
      for i, input_file in enumerate(input_files):
        file_ending = filename_type_ending(input_file)
        if file_ending.endswith(SOURCE_ENDINGS):
          temp_file = temp_files[i]
          logging.debug('optimizing %s', input_file)
          shared.Building.llvm_opt(temp_file, llvm_opts)

  # If we were just asked to generate bitcode, stop there
  if final_suffix not in JS_CONTAINING_SUFFIXES:
    if not specified_target:
      for input_file in input_files:
        shutil.move(in_temp(unsuffixed(uniquename(input_file)) + '.o'), unsuffixed_basename(input_file) + '.' + final_suffix)
    else:
      if len(input_files) == 1:
        temp_output_base = in_temp(unsuffixed(uniquename(input_files[0])))
        if specified_target.endswith('/') or specified_target.endswith('\\') or os.path.isdir(specified_target): # User passed '-o <directory' as the location to output to.
          obj_output_name = os.path.join(specified_target, os.path.splitext(os.path.basename(input_file))[0] + default_object_extension)
          logging.debug('User specified -o <directoryname> as the location of the output. Generating output file ' + obj_output_name)
          try:
            shutil.move(temp_output_base + '.o', obj_output_name)
          except IOError, e:
            logging.error('Could not write to output file ' + obj_output_name + '. Perhaps the output directory does not exist?')
            exit(1)
        else: # User passed '-o <filename>' as the location to output to.
          shutil.move(temp_output_base + '.o', specified_target)
        if os.path.exists(temp_output_base + '.d'):
          # There was a .d file generated, from -MD or -MMD and friends, save a copy of it to where the output resides,
          # adjusting the target name away from the temporary file name to the specified target.
          # It will be deleted with the rest of the temporary directory.
          deps = open(temp_output_base + '.d').read()
          deps = deps.replace(temp_output_base + '.o', specified_target)
          with open(os.path.join(os.path.dirname(specified_target), os.path.basename(unsuffixed(input_files[0]) + '.d')), "w") as out_dep:
            out_dep.write(deps)
      else:
        assert len(original_input_files) == 1 or not has_dash_c, 'fatal error: cannot specify -o with -c with multiple files' + str(sys.argv) + ':' + str(original_input_files)
        # We have a specified target (-o <target>), which is not JavaScript or HTML, and
        # we have multiple files: Link them
        logging.debug('link: ' + str(temp_files) + specified_target)
        shared.Building.link(temp_files, specified_target)
    exit(0)

  log_time('bitcodeize inputs')

  ## Continue on to create JavaScript

  logging.debug('will generate JavaScript')

  if not LEAVE_INPUTS_RAW and \
     not shared.Settings.BUILD_AS_SHARED_LIB and \
     not shared.Settings.SIDE_MODULE: # shared libraries/side modules link no C libraries, need them in parent
    extra_files_to_link = system_libs.calculate(temp_files, in_temp, stdout, stderr)
  else:
    extra_files_to_link = []

  log_time('calculate system libraries')

  # First, combine the bitcode files if there are several. We must also link if we have a singleton .a
  if len(input_files) + len(extra_files_to_link) > 1 or \
     (not LEAVE_INPUTS_RAW and not (suffix(temp_files[0]) in BITCODE_ENDINGS or suffix(temp_files[0]) in DYNAMICLIB_ENDINGS) and shared.Building.is_ar(temp_files[0])):
    linker_inputs = temp_files + extra_files_to_link
    logging.debug('linking: ' + str(linker_inputs))
    shared.Building.link(linker_inputs, in_temp(target_basename + '.bc'), force_archive_contents=len([temp for temp in temp_files if not temp.endswith(STATICLIB_ENDINGS)]) == 0)
    final = in_temp(target_basename + '.bc')
  else:
    if not LEAVE_INPUTS_RAW:
      shutil.move(temp_files[0], in_temp(target_basename + '.bc'))
      final = in_temp(target_basename + '.bc')
    else:
      final = in_temp(input_files[0])
      shutil.copyfile(input_files[0], final)

  log_time('link')

  if DEBUG:
    logging.debug('saving intermediate processing steps to %s', shared.EMSCRIPTEN_TEMP_DIR)

    intermediate_counter = 0
    def save_intermediate(name=None, suffix='js'):
      global intermediate_counter
      shutil.copyfile(final, os.path.join(shared.EMSCRIPTEN_TEMP_DIR, 'emcc-%d%s.%s' % (intermediate_counter, '' if name is None else '-' + name, suffix)))
      intermediate_counter += 1

    if not LEAVE_INPUTS_RAW: save_intermediate('basebc', 'bc')

  # Optimize, if asked to
  if not LEAVE_INPUTS_RAW:
    link_opts = [] if debug_level >= 4 else ['-strip-debug'] # remove LLVM debug if we are not asked for it

    if llvm_lto >= 2:
      logging.debug('running LLVM opt -O3 as pre-LTO')
      shared.Building.llvm_opt(in_temp(target_basename + '.bc'), ['-O3'])
      if DEBUG: save_intermediate('opt', 'bc')

    # If we can LTO, do it before dce, since it opens up dce opportunities
    if shared.Building.can_build_standalone() and llvm_lto and llvm_lto != 2 and shared.Building.can_use_unsafe_opts():
      if not shared.Building.can_inline(): link_opts.append('-disable-inlining')
      # do not internalize in std-link-opts - it ignores internalize-public-api-list - and add a manual internalize
      link_opts += ['-disable-internalize'] + shared.Building.get_safe_internalize() + ['-std-link-opts']
    else:
      # At minimum remove dead functions etc., this potentially saves a lot in the size of the generated code (and the time to compile it)
      link_opts += shared.Building.get_safe_internalize() + ['-globaldce']

    if (not save_bc and not fastcomp) or AUTODEBUG:
      # let llvm opt directly emit ll, to skip writing and reading all the bitcode
      link_opts += ['-S']
      shared.Building.llvm_opt(final, link_opts, final + '.link.ll')
      final = final + '.link.ll'
      if DEBUG: save_intermediate('linktime', 'll')
    else:
      if fastcomp and not save_bc:
        # Simplify LLVM bitcode for fastcomp
        link_opts = pre_fastcomp_opts + link_opts + fastcomp_opts
      shared.Building.llvm_opt(final, link_opts)
      if DEBUG: save_intermediate('linktime', 'bc')
      if save_bc:
        shutil.copyfile(final, save_bc)
        if fastcomp:
          shared.Building.llvm_opt(final, fastcomp_opts, final + '.adsimp.bc')
          final += '.adsimp.bc'
          if DEBUG: save_intermediate('adsimp', 'bc')

  # Prepare .ll for Emscripten
  if not LEAVE_INPUTS_RAW:
    if save_bc:
      final = shared.Building.llvm_dis(final, final + '.ll')
  else:
    assert len(input_files) == 1
  if DEBUG and save_bc: save_intermediate('ll', 'll')

  if AUTODEBUG:
    logging.debug('autodebug')
    execute([shared.PYTHON, shared.AUTODEBUGGER, final, final + '.ad.ll'])
    final += '.ad.ll'
    if DEBUG: save_intermediate('autodebug', 'll')

  # Simplify bitcode after autodebug
  if fastcomp and (AUTODEBUG or LEAVE_INPUTS_RAW):
    shared.Building.llvm_opt(final, fastcomp_opts, final + '.adsimp.bc')
    final += '.adsimp.bc'
    if DEBUG: save_intermediate('adsimp', 'bc')

  log_time('post-link')

  # Emscripten
  logging.debug('LLVM => JS')
  extra_args = [] if not js_libraries else ['--libraries', ','.join(map(os.path.abspath, js_libraries))]
  if jcache: extra_args.append('--jcache')
  final = shared.Building.emscripten(final, append_ext=False, extra_args=extra_args)
  if DEBUG: save_intermediate('original')

  log_time('emscript (llvm=>js)')

  # Embed and preload files
  if len(preload_files) + len(embed_files) > 0:
    logging.debug('setting up files')
    file_args = []
    if len(preload_files) > 0:
      file_args.append('--preload')
      file_args += preload_files
    if len(embed_files) > 0:
      file_args.append('--embed')
      file_args += embed_files
    if len(exclude_files) > 0:
      file_args.append('--exclude')
      file_args += exclude_files
    if Compression.on:
      file_args += ['--compress', Compression.encoder, Compression.decoder, Compression.js_name]
    if use_preload_cache:
      file_args.append('--use-preload-cache')
    if no_heap_copy:
      file_args.append('--no-heap-copy')
    file_code = execute([shared.PYTHON, shared.FILE_PACKAGER, unsuffixed(target) + '.data'] + file_args, stdout=PIPE)[0]
    pre_js = file_code + pre_js

  # Apply pre and postjs files
  if pre_js or post_js:
    logging.debug('applying pre/postjses')
    src = open(final).read()
    final += '.pp.js'
    open(final, 'w').write(pre_js + src + post_js)
    if DEBUG: save_intermediate('pre-post')

  # Add bindings glue if used
  if bind:
    logging.debug('adding embind glue')
    src = open(final).read().replace('// {{PRE_RUN_ADDITIONS}}', '// {{PRE_RUN_ADDITIONS}}\n' +
            open(shared.path_from_root('src', 'embind', 'embind.js')).read() +
            open(shared.path_from_root('src', 'embind', 'emval.js')).read()
          )
    final += '.bd.js'
    open(final, 'w').write(src)
    if DEBUG: save_intermediate('bind')

  # Apply a source code transformation, if requested
  if js_transform:
    shutil.copyfile(final, final + '.tr.js')
    final += '.tr.js'
    posix = True if not shared.WINDOWS else False
    logging.debug('applying transform: %s', js_transform)
    subprocess.check_call(shlex.split(js_transform, posix=posix) + [os.path.abspath(final)])
    if DEBUG: save_intermediate('transformed')

  js_transform_tempfiles = [final]

  if memory_init_file:
    if shared.Settings.USE_TYPED_ARRAYS != 2:
      if type(memory_init_file) == int: logging.warning('memory init file requires typed arrays mode 2')
    else:
      memfile = target + '.mem'
      shared.try_delete(memfile)
      def repl(m):
        # handle chunking of the memory initializer
        s = m.groups(0)[0]
        open(memfile, 'wb').write(''.join(map(lambda x: chr(int(x or '0')), s.split(','))))
        if DEBUG:
          # Copy into temp dir as well, so can be run there too
          temp_memfile = os.path.join(shared.EMSCRIPTEN_TEMP_DIR, os.path.basename(memfile))
          if os.path.abspath(memfile) != os.path.abspath(memfile):
            shutil.copyfile(memfile, temp_memfile)
        return 'var memoryInitializer = "%s";' % os.path.basename(memfile)
      src = re.sub(shared.JS.memory_initializer_pattern, repl, open(final).read(), count=1)
      open(final + '.mem.js', 'w').write(src)
      final += '.mem.js'
      src = None
      js_transform_tempfiles[-1] = final # simple text substitution preserves comment line number mappings
      if DEBUG:
        if os.path.exists(memfile):
          save_intermediate('meminit')
          logging.debug('wrote memory initialization to %s', memfile)
        else:
          logging.debug('did not see memory initialization')
  elif shared.Settings.USE_TYPED_ARRAYS == 2 and not shared.Settings.MAIN_MODULE and not shared.Settings.SIDE_MODULE:
    # not writing a binary init, but we can at least optimize them by splitting them up
    src = open(final).read()
    src = shared.JS.optimize_initializer(src)
    if src is not None:
      logging.debug('optimizing memory initialization')
      open(final + '.mem.js', 'w').write(src)
      final += '.mem.js'
      src = None

  log_time('source transforms')

  # It is useful to run several js optimizer passes together, to save on unneeded unparsing/reparsing
  js_optimizer_queue = []
  js_optimizer_extra_info = {}
  js_optimizer_queue_history = []
  def flush_js_optimizer_queue():
    global final, js_optimizer_queue, js_optimizer_extra_info, js_optimizer_queue_history
    if len(js_optimizer_extra_info) == 0:
      js_optimizer_extra_info = None
    if len(js_optimizer_queue) > 0 and not(not shared.Settings.ASM_JS and len(js_optimizer_queue) == 1 and js_optimizer_queue[0] == 'last'):

      def add_opt_args(args):
        if shared.Settings.ASM_JS:
          args = ['asm'] + args
          if shared.Settings.PRECISE_F32:
            args = ['asmPreciseF32'] + args
        return args

      if DEBUG != '2':
        js_optimizer_queue = add_opt_args(js_optimizer_queue)
        logging.debug('applying js optimization passes: %s', js_optimizer_queue)
        final = shared.Building.js_optimizer(final, js_optimizer_queue, jcache, debug_level >= 4, js_optimizer_extra_info)
        js_transform_tempfiles.append(final)
        if DEBUG: save_intermediate('js_opts')
      else:
        for name in js_optimizer_queue:
          passes = add_opt_args([name])
          if shared.Settings.ASM_JS:
            passes = ['asm'] + passes
          logging.debug('applying js optimization pass: %s', passes)
          final = shared.Building.js_optimizer(final, passes, jcache, debug_level >= 4, js_optimizer_extra_info)
          js_transform_tempfiles.append(final)
          save_intermediate(name)
      js_optimizer_queue_history += js_optimizer_queue
      js_optimizer_queue = []
    js_optimizer_extra_info = {}

  if opt_level >= 1 and js_opts:
    logging.debug('running pre-closure post-opts')

    if DEBUG == '2':
      # Clean up the syntax a bit
      final = shared.Building.js_optimizer(final, [], jcache, debug_level >= 4)
      js_transform_tempfiles.append(final)
      if DEBUG: save_intermediate('pretty')

    def get_eliminate():
      if shared.Settings.ALLOW_MEMORY_GROWTH:
        return 'eliminateMemSafe'
      else:
        return 'eliminate'

    if opt_level >= 2:
      js_optimizer_queue += [get_eliminate()]

      if shared.Settings.AGGRESSIVE_VARIABLE_ELIMINATION:
        js_optimizer_queue += ['aggressiveVariableElimination']

      js_optimizer_queue += ['simplifyExpressions']

      if opt_level >= 3 and shared.Settings.PRECISE_F32: js_optimizer_queue += ['optimizeFrounds']

  if closure and not shared.Settings.ASM_JS:
    flush_js_optimizer_queue()

    logging.debug('running closure')
    # no need to add this to js_transform_tempfiles, because closure and
    # debug_level > 0 are never simultaneously true
    final = shared.Building.closure_compiler(final)
    if DEBUG: save_intermediate('closure')

  if js_opts:
    if shared.Settings.ASM_JS and shared.Settings.SAFE_HEAP: js_optimizer_queue += ['safeHeap']

    if shared.Settings.OUTLINING_LIMIT > 0 and shared.Settings.ASM_JS:
      js_optimizer_queue += ['outline']
      js_optimizer_extra_info['sizeToOutline'] = shared.Settings.OUTLINING_LIMIT

    if opt_level >= 2 and (not closure or shared.Settings.ASM_JS) and shared.Settings.RELOOP and debug_level < 3:
      if shared.Settings.ASM_JS and opt_level >= 3 and shared.Settings.OUTLINING_LIMIT == 0:
        js_optimizer_queue += ['registerizeHarder']
      else:
        js_optimizer_queue += ['registerize']

    if opt_level >= 2:
      if debug_level < 2 and shared.Settings.ASM_JS: js_optimizer_queue += ['minifyNames']
      if debug_level == 0: js_optimizer_queue += ['minifyWhitespace']

    if closure and shared.Settings.ASM_JS:
      js_optimizer_queue += ['closure']

    if not shared.Settings.SIDE_MODULE: js_optimizer_queue += ['last'] # side modules are not finalized until after relocation

    flush_js_optimizer_queue()

  log_time('js opts')

  # Remove some trivial whitespace # TODO: do not run when compress has already been done on all parts of the code
  #src = open(final).read()
  #src = re.sub(r'\n+[ \n]*\n+', '\n', src)
  #open(final, 'w').write(src)

  def generate_source_map(map_file_base_name, offset=0):
    jsrun.run_js(shared.path_from_root('tools', 'source-maps', 'sourcemapper.js'),
      shared.NODE_JS, js_transform_tempfiles +
        ['--sourceRoot', os.getcwd(),
         '--mapFileBaseName', map_file_base_name,
         '--offset', str(offset)])

  # If we were asked to also generate HTML, do that
  if final_suffix == 'html':
    logging.debug('generating HTML')
    shell = open(shell_path).read()
    assert '{{{ SCRIPT }}}' in shell, 'HTML shell must contain  {{{ SCRIPT }}}  , see src/shell.html for an example'
    html = open(target, 'w')
    js_target = unsuffixed(target) + '.js'
    base_js_target = os.path.basename(js_target)
    if proxy_to_worker:
      html.write(shell.replace('{{{ SCRIPT }}}', '<script>' + open(shared.path_from_root('src', 'proxyClient.js')).read().replace('{{{ filename }}}', target_basename) + '</script>'))
      shutil.move(final, js_target)
    elif not Compression.on:
      # Normal code generation path
      if debug_level >= 4:
        generate_source_map(target)
      shutil.move(final, js_target)
      need_mods = shared.Settings.PRECISE_F32 == 2
      if not need_mods:
        # Non-modifiable code, just load the code directly
        script_tag = '''<script async type="text/javascript" src="%s"></script>''' % base_js_target
      else:
        # Potentially-modifiable code, load as text, modify, then execute. This lets you
        # patch the code on the client machine right before it is executed, perhaps based
        # on information about the client.
        checks = []
        mods = []
        if shared.Settings.PRECISE_F32 == 2:
          checks.append('!Math.fround')
          if 'minifyNames' not in js_optimizer_queue_history:
            # simple dumb replace
            mods.append('''
console.log('optimizing out Math.fround calls');
code = code.replace(/Math_fround\(/g, '(').replace("'use asm'", "'almost asm'")
''')
          else:
            # minified, not quite so simple - TODO
            mods.append('''
try {
  console.log('optimizing out Math.fround calls');
  var m = /var ([^=]+)=global\.Math\.fround;/.exec(code);
  var minified = m[1];
  if (!minified) throw 'fail';
  var startAsm = code.indexOf('// EMSCRIPTEN_START_FUNCS');
  var endAsm = code.indexOf('// EMSCRIPTEN_END_FUNCS');
  var asm = code.substring(startAsm, endAsm);
  do {
    var moar = false; // we need to re-do, as x(x( will not be fixed
    asm = asm.replace(new RegExp('[^a-zA-Z0-9\\\\$\\\\_]' + minified + '\\\\(', 'g'), function(s) { moar = true; return s[0] + '(' });
  } while (moar);
  code = code.substring(0, startAsm) + asm + code.substring(endAsm);
  code = code.replace("'use asm'", "'almost asm'");
} catch(e) { console.log('failed to optimize out Math.fround calls ' + e) }
''')

        fixes = ''
        for i in range(len(checks)):
          fixes += 'if (' + checks[i] + ') { ' + mods[i] + ' }\n'

        # if all the checks are negative, just emit a script tag normally, that's better.
        # otherwise, do an xhr to get the code as text, modify, and load asynchronously
        code = 'if (!(' + ' || '.join(checks) + ''')) {
  var script = document.createElement('script');
  script.src = "''' + base_js_target + '''";
  document.body.appendChild(script);
} else {
  var codeXHR = new XMLHttpRequest();
  codeXHR.open('GET', '%s', true);
  codeXHR.onload = function() {
    var code = codeXHR.responseText;
    %s
    var blob = new Blob([code], { type: 'text/javascript' });
    codeXHR = null;
    var src = URL.createObjectURL(blob);
    var script = document.createElement('script');
    script.src = URL.createObjectURL(blob);
    script.onload = function() {
      URL.revokeObjectURL(script.src);
    };
    document.body.appendChild(script);
  };
  codeXHR.send(null);
}
''' % (base_js_target, fixes)
        script_tag = '''<script>%s</script>''' % code
      html.write(shell.replace('{{{ SCRIPT }}}', script_tag))
    else:
      # Compress the main code
      shutil.move(final, js_target)
      Compression.compress(js_target)

      # Run the decompressor in a worker, and add code to
      #   1. download the compressed file
      #   2. decompress to a typed array
      #   3. convert to a string of source code
      #   4. insert a script element with that source code (more effective than eval)
      decoding = '''
        var decompressWorker = new Worker('decompress.js');
        var decompressCallbacks = [];
        var decompressions = 0;
        Module["decompress"] = function(data, callback) {
          var id = decompressCallbacks.length;
          decompressCallbacks.push(callback);
          decompressWorker.postMessage({ data: data, id: id });
          if (Module['setStatus']) {
            decompressions++;
            Module['setStatus']('Decompressing...');
          }
        };
        decompressWorker.onmessage = function(event) {
          decompressCallbacks[event.data.id](event.data.data);
          decompressCallbacks[event.data.id] = null;
          if (Module['setStatus']) {
            decompressions--;
            if (decompressions == 0) {
              Module['setStatus']('');
            }
          }
        };
        var compiledCodeXHR = new XMLHttpRequest();
        compiledCodeXHR.open('GET', '%s', true);
        compiledCodeXHR.responseType = 'arraybuffer';
        compiledCodeXHR.onload = function() {
          var arrayBuffer = compiledCodeXHR.response;
          if (!arrayBuffer) throw('Loading compressed code failed.');
          var byteArray = new Uint8Array(arrayBuffer);
          Module.decompress(byteArray, function(decompressed) {
            var source = Array.prototype.slice.apply(decompressed).map(function(x) { return String.fromCharCode(x) }).join(''); // createObjectURL instead?
            var scriptTag = document.createElement('script');
            scriptTag.setAttribute('type', 'text/javascript');
            scriptTag.innerHTML = source;
            document.body.appendChild(scriptTag);
          });
        };
        compiledCodeXHR.send(null);
''' % Compression.compressed_name(base_js_target)
      html.write(shell.replace('{{{ SCRIPT }}}', '<script>' + decoding + '</script>'))

      # Add decompressor with web worker glue code
      decompressor = open('decompress.js', 'w')
      decompressor.write(open(Compression.decoder).read())
      decompressor.write('''
        onmessage = function(event) {
          postMessage({ data: %s(event.data.data), id: event.data.id });
        };
''' % Compression.js_name)
      decompressor.close()

    html.close()
  else:
    if split_js_file:
      from tools.split import split_javascript_file
      split_javascript_file(final, unsuffixed(target), split_js_file)
    else:
      if debug_level >= 4: generate_source_map(target)
      # copy final JS to output
      shutil.move(final, target)

  log_time('final emitting')

  if DEBUG: logging.debug('total time: %.2f seconds', (time.time() - start_time))

finally:
  if not TEMP_DIR:
    try:
      shutil.rmtree(temp_dir)
    except:
      pass
  else:
    logging.info('emcc saved files are in:' + temp_dir)

